{
  "name": "hapi-auth-cookie",
  "description": "Cookie authentication plugin",
  "version": "4.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/hapijs/hapi-auth-cookie"
  },
  "main": "lib/index.js",
  "keywords": [
    "hapi",
    "plugin",
    "auth",
    "cookie",
    "session"
  ],
  "engines": {
    "node": ">=4.x.x"
  },
  "dependencies": {
    "boom": "3.x.x",
    "hoek": "3.x.x",
    "joi": "7.x.x"
  },
  "peerDependencies": {
    "hapi": ">=10.x.x"
  },
  "devDependencies": {
    "code": "2.x.x",
    "hapi": "10.x.x",
    "lab": "8.x.x"
  },
  "scripts": {
    "test": "lab -a code -t 100 -L",
    "test-cov-html": "lab -a code -r html -o coverage.html"
  },
  "license": "BSD-3-Clause",
  "readme": "### hapi-auth-cookie\n\n[**hapi**](https://github.com/hapijs/hapi) Cookie authentication plugin\n\n[![Build Status](https://secure.travis-ci.org/hapijs/hapi-auth-cookie.png)](http://travis-ci.org/hapijs/hapi-auth-cookie)\n\nLead Maintainer: [James Weston](https://github.com/jaw187)\n\nCookie authentication provides a simple cookie-based session management. The user has to be\nauthenticated via other means, typically a web form, and upon successful authentication,\nreceive a reply with a session cookie. Subsequent requests containing the session cookie are\nauthenticated (the cookie uses [Iron](https://github.com/hueniverse/iron) to encrypt and sign the\nsession content) and validated via the provided `validateFunc` in case the cookie's encrypted\ncontent requires validation on each request. Note that cookie operates as a bearer token and anyone\nin possession of the cookie content can use it to impersonate its true owner. The `'cookie`' scheme\ntakes the following required options:\n\n- `cookie` - the cookie name. Defaults to `'sid'`.\n- `password` - used for Iron cookie encoding.\n- `ttl` - sets the cookie expires time in milliseconds. Defaults to single browser session (ends\n  when browser closes).\n- `domain` - sets the cookie Domain value. Defaults to none.\n- `path` - sets the cookie path value. Defaults to `/`.\n- `clearInvalid` - if `true`, any authentication cookie that fails validation will be marked as\n  expired in the response and cleared. Defaults to `false`.\n- `keepAlive` - if `true`, automatically sets the session cookie after validation to extend the\n  current session for a new `ttl` duration. Defaults to `false`.\n- `isSecure` - if `false`, the cookie is allowed to be transmitted over insecure connections which\n  exposes it to attacks. Defaults to `true`.\n- `isHttpOnly` - if `false`, the cookie will not include the 'HttpOnly' flag. Defaults to `true`.\n- `redirectTo` - optional login URI to redirect unauthenticated requests to. Note that using\n  `redirectTo` with authentication mode `'try'` will cause the protected endpoint to always\n  redirect, voiding `'try'` mode. To set an individual route to use or disable redirections, use\n  the route `plugins` config (`{ config: { plugins: { 'hapi-auth-cookie': { redirectTo: false } } } }`).\n  Defaults to no redirection.\n- `appendNext` - if `true` and `redirectTo` is `true`, appends the current request path to the\n  query component of the `redirectTo` URI using the parameter name `'next'`. Set to a string to use\n  a different parameter name. Defaults to `false`.\n- `redirectOnTry` - if `false` and route authentication mode is `'try'`, authentication errors will\n  not trigger a redirection. Requires **hapi** version 6.2.0 or newer. Defaults to `true`;\n- `validateFunc` - an optional session validation function used to validate the content of the\n  session cookie on each request. Used to verify that the internal session state is still valid\n  (e.g. user account still exists). The function has the signature `function(request, session, callback)`\n  where:\n    - `request` - is the Hapi request object of the request which is being authenticated.\n    - `session` - is the session object set via `request.auth.session.set()`.\n    - `callback` - a callback function with the signature `function(err, isValid, credentials)`\n      where:\n        - `err` - an internal error.\n        - `isValid` - `true` if the content of the session is valid, otherwise `false`.\n        - `credentials` - a credentials object passed back to the application in\n          `request.auth.credentials`. If value is `null` or `undefined`, defaults to `session`. If\n          set, will override the current cookie as if `request.auth.session.set()` was called.\n\nWhen the cookie scheme is enabled on a route, the `request.auth.session` objects is decorated with\nthe following methods:\n- `set(session)` - sets the current session. Must be called after a successful login to begin the\n  session. `session` must be a non-null object, which is set on successful subsequent\n  authentications in `request.auth.credentials` where:\n    - `session` - the session object.\n- `set(key, value)` - sets a specific object key on the current session (which must already exist)\n  where:\n    - `key` - session key string.\n    - `value` - value to assign key.\n- `clear([key])` - clears the current session or session key where:\n    - `key` - optional key string to remove a specific property of the session. If none provided,\n      defaults to removing the entire session which is used to log the user out.\n- `ttl(msecs)` - sets the ttl of the current active session where:\n    - `msecs` - the new ttl in milliseconds.\n\nBecause this scheme decorates the `request` object with session-specific methods, it cannot be\nregistered more than once.\n\n```javascript\n'use strict';\n\nconst Hapi = require('hapi');\n\nlet uuid = 1;       // Use seq instead of proper unique identifiers for demo only\n\nconst users = {\n    john: {\n        id: 'john',\n        password: 'password',\n        name: 'John Doe'\n    }\n};\n\nconst home = function (request, reply) {\n\n    reply('<html><head><title>Login page</title></head><body><h3>Welcome '\n      + request.auth.credentials.name\n      + '!</h3><br/><form method=\"get\" action=\"/logout\">'\n      + '<input type=\"submit\" value=\"Logout\">'\n      + '</form></body></html>');\n};\n\nconst login = function (request, reply) {\n\n    if (request.auth.isAuthenticated) {\n        return reply.redirect('/');\n    }\n\n    let message = '';\n    let account = null;\n\n    if (request.method === 'post') {\n\n        if (!request.payload.username ||\n            !request.payload.password) {\n\n            message = 'Missing username or password';\n        }\n        else {\n            account = users[request.payload.username];\n            if (!account ||\n                account.password !== request.payload.password) {\n\n                message = 'Invalid username or password';\n            }\n        }\n    }\n\n    if (request.method === 'get' ||\n        message) {\n\n        return reply('<html><head><title>Login page</title></head><body>'\n            + (message ? '<h3>' + message + '</h3><br/>' : '')\n            + '<form method=\"post\" action=\"/login\">'\n            + 'Username: <input type=\"text\" name=\"username\"><br>'\n            + 'Password: <input type=\"password\" name=\"password\"><br/>'\n            + '<input type=\"submit\" value=\"Login\"></form></body></html>');\n    }\n\n    const sid = String(++uuid);\n    request.server.app.cache.set(sid, { account: account }, 0, (err) => {\n\n        if (err) {\n            reply(err);\n        }\n\n        request.auth.session.set({ sid: sid });\n        return reply.redirect('/');\n    });\n};\n\nconst logout = function (request, reply) {\n\n    request.auth.session.clear();\n    return reply.redirect('/');\n};\n\nconst server = new Hapi.Server();\nserver.connection({ port: 8000 });\n\nserver.register(require('../'), (err) => {\n\n    if (err) {\n        throw err;\n    }\n\n    const cache = server.cache({ segment: 'sessions', expiresIn: 3 * 24 * 60 * 60 * 1000 });\n    server.app.cache = cache;\n\n    server.auth.strategy('session', 'cookie', true, {\n        password: 'secret',\n        cookie: 'sid-example',\n        redirectTo: '/login',\n        isSecure: false,\n        validateFunc: function (request, session, callback) {\n\n            cache.get(session.sid, (err, cached) => {\n\n                if (err) {\n                    return callback(err, false);\n                }\n\n                if (!cached) {\n                    return callback(null, false);\n                }\n\n                return callback(null, true, cached.account);\n            });\n        }\n    });\n\n    server.route([\n        { method: 'GET', path: '/', config: { handler: home } },\n        { method: ['GET', 'POST'], path: '/login', config: { handler: login, auth: { mode: 'try' }, plugins: { 'hapi-auth-cookie': { redirectTo: false } } } },\n        { method: 'GET', path: '/logout', config: { handler: logout } }\n    ]);\n\n    server.start(() => {\n\n        console.log('Server ready');\n    });\n});\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hapijs/hapi-auth-cookie/issues"
  },
  "_id": "hapi-auth-cookie@4.0.0",
  "dist": {
    "shasum": "fdb0779628e64328e3dd424c52f83ecb7d2ddd62"
  },
  "_from": "hapi-auth-cookie@",
  "_resolved": "https://registry.npmjs.org/hapi-auth-cookie/-/hapi-auth-cookie-4.0.0.tgz"
}
